/* The CSS you are about to write is a common set of properties used to ensure elements are completely hidden visually. */
/* The span[class~="sr-only"] selector will select any span element whose class includes sr-only. */
/* Rather than having to constantly double-check you are not overwriting your earlier properties, you can use the !important keyword to ensure these properties are always applied, regardless of order or specificity. */
span[class~="sr-only"]{
    border: 0 !important;
    width: 1px !important;
    height: 1px !important;
/* The CSS clip property is used to define the visible portions of an element. */
    clip: rect(1px, 1px, 1px, 1px) !important;
/* The clip-path property determines the shape the clip property should take.forming the clip-path into a rectangle within the element. */
    clip-path: inset(50%) !important;
    -webkit-clip-path: inset(50%) !important;
/* To prevent the text content from overflowing, give your span[class~="sr-only"] selector an overflow property set to hidden and a white-space property set to nowrap. */
     overflow: hidden !important;
     white-space: nowrap !important;
/* Finally, you need to take these hidden elements out of the document flow. This will ensure that not only are they no longer visible, but they are not even within the page view. BELOW */     
     position: absolute !important;
     padding: 0 !important;
     margin: -1px !important;
}
html{
    box-sizing: border-box;
}
body{
    font-family: sans-serif;
    color: #0a0a23;
}
h1{
    max-width: 37.25rem;
    margin: 0 auto;
    padding: 1.5rem 1.25rem;
}
/* Target your flex container with an h1 .flex selector. Give it a display property set to flex to enable the flexbox layout. Then set the flex-direction property to column-reverse - this will display the nested elements from bottom to top. Finally, set the gap property to 1rem to create some space between the elements. */
h1 .flex{
    display: flex;
    flex-direction: column-reverse;
    gap: 1rem;
}
/* The :first-of-type pseudo-selector is used to target the first element that matches the selector.Remember that your span elements are reversed, visually, so this will appear to be the second element on the page. */
h1 .flex span:first-of-type{
    font-size: 0.7em;
}
/* The :last-of-type pseudo-selector does the exact opposite - it targets the last element that matches the selector. */
h1 .flex span:last-of-type{
    font-size: 1.2em;
}
section{
    max-width: 40rem;
    margin: 0 auto;
    border: 2px solid #d0d0d5;
}
#years{
    display: flex;
    justify-content: flex-end;
    top: 0;
    position: sticky;
    color: #fff;
    background-color: #0a0a23;
/* The calc() function is a CSS function that allows you to calculate a value based on other values. For example, you can use it to calculate the width of the viewport minus the margin of an element: .example {
  margin: 10px;
  width: calc(100% - 20px);} */
  margin: 0 -2px;
  padding: 0.5rem calc(1.25rem + 2px) 0.5rem 0;
/* Ensure your years do not get hidden. SET */
  z-index: 999; 
}
#years span[class]{
    font-weight: bold;
    width: 4.5rem;
    text-align: right;
}
.table-wrap{
    padding: 0 0.75rem 1.5rem 0.75rem;
}
/* The :not() pseudo-selector is used to target all elements that do not match the selector - in this case, any of your span elements that do not have the sr-only class. This ensures that your earlier rules for the span[class~="sr-only"] selector are not overwritten. */
table{
/* which will allow cell borders to collapse into a single border, instead of a border around each cell. */    
    border-collapse: collapse;
    border: 0;
    width: 100%;
    position: relative;
    margin-top: 3rem;
}
table caption{
    font-size: 1.3em;
    font-weight: normal;
    color: #356eaf;
    position: absolute;
    top: -2.25rem;
    left: 0.5rem;
}
td{
    max-width: 4rem;
    min-width: 4rem;
    width: 100vw;
}
tbody th{
/* give them a width of the entire container, less 12rem */
    width: calc(100% - 12rem);
}
/* The [attribute="value"] selector targets any element that has an attribute with a specific value. */
tr[class="total"]{
    font-weight: bold;
    border-bottom: 4px double #0a0a23;
}
/* Using the same selector syntax, target the th elements within your table rows where the class is total. */
tr[class="total" ] th{
    text-align: left;
    padding: 0.5rem 0 0.25rem 0.5rem
}
/* The key difference between tr[class="total"] and tr.total is that the first will select tr elements where the only class is total. The second will select tr elements where the class includes total. */
tr.total td{
    padding: 0 0.25rem;
    text-align: right;
}
/* The :nth-of-type() pseudo-selector is used to target specific elements based on their order among siblings of the same type. */
tr.total td:nth-of-type(3){
    padding-right: 0.5rem;
}
tr.total:hover{
    background-color: #99c9ff;
}
td.current{
    font-style: italic;
}
tr.data{
    background-image:linear-gradient(to bottom, #dfdfe2 1.845rem, white 1.845rem);
}
tr.data th{
  text-align: left;
  padding: 0.3rem 0 0 0.5rem;
}
tr.data th .description{
    display: block;
    font-style: italic;
    font-weight: normal;
    padding: 1rem 0 0.75rem;
    margin-right: -13.5rem;
}
tr.data td{
    padding: 0.3rem 0.25rem 0;
    vertical-align: top;
    text-align: right;
}
tr.data td:last-of-type{
    padding-right:  0.5rem;
}
